use serde_json::Value;
use std::error::Error;
use std::fs::{self, File};
use std::io::{BufRead, BufReader, Write};
use std::path::Path;


fn package_version(json: &Value) -> Result<&str, Box<dyn Error>> {
    json
    .get("version")
    .ok_or("No version found")?
    .as_str()
    .ok_or("Version is not a string".into())
}

fn write_version<'a>(f: &'a mut File, package_version: &'a str) -> Result<&'a str, Box<dyn Error>> {
    f.write_all(
        format!(
            "pub const PACKAGE_VERSION: &'static str = \"{}\";\n",
            package_version
        )
        .as_bytes(),
    )?;
    Ok(package_version)
}

fn set_cargo_version(package_version: &str, file: &str) -> Result<(), Box<dyn Error>> {
    let cargo_toml = File::open(std::path::Path::new(file)).expect("Cargo.toml not found");
    let reader = BufReader::new(cargo_toml);
    let lines = reader.lines().map(|l| l.unwrap()).collect::<Vec<String>>();
    let mut cargo_toml = File::create(std::path::Path::new(file)).expect("Cargo.toml not found");
    for line in lines {
        if line.starts_with("version") {
            writeln!(cargo_toml, "version = \"{}\"", package_version)?;
        } else {
            writeln!(cargo_toml, "{}", line)?;
        }
    }
    cargo_toml.sync_all()?;
    Ok(())
}

fn set_readme_version(package_version: &str, file: &str) -> Result<(), Box<dyn Error>> {
    let readme = File::open(std::path::Path::new(file)).expect("README.md not found");
    let reader = BufReader::new(readme);
    let lines = reader.lines().map(|l| l.unwrap()).collect::<Vec<String>>();
    let mut readme = File::create(std::path::Path::new(file)).expect("README.md not found");
    for line in lines {
        if line.starts_with("# RootAsRole (V") {
            let mut s = line.split("(V").next().unwrap().to_string();
            let end = line.split(')').nth(1).unwrap();
            s.push_str(&format!("(V{}){}", package_version, end));
            writeln!(readme, "{}", s)?;
        } else {
            writeln!(readme, "{}", line)?;
        }
    }
    readme.sync_all()?;
    Ok(())
}

fn main() {
    println!("cargo:rerun-if-changed=resources/rootasrole.json");
    println!("cargo:rerun-if-changed=build.rs");

    let json: Value = include_str!("resources/rootasrole.json")
        .parse()
        .expect("Failed to parse rootasrole.json");
    let package_version = package_version(&json).expect("Failed to get package version");
    let dest_path = std::path::Path::new("src").join("version.rs");
    if dest_path.exists() && fs::read_to_string(&dest_path).unwrap().ends_with(&format!("\"{}\";\n",package_version)) {
        return;
    }
    let mut f = File::create(dest_path).unwrap();
    f.write_all(b"// This file is generated by build.rs\n")
        .unwrap();
    f.write_all(b"// Do not edit this file directly\n").unwrap();
    f.write_all(b"// Instead edit build.rs and run cargo build\n")
        .unwrap();
    write_version(&mut f, &package_version).expect("Failed to write version");
    if let Err(err) = set_cargo_version(package_version, "Cargo.toml") {
        eprintln!("cargo:warning={}", err);
    }
    //if folder capable/ exists
    if Path::new("capable/capable").is_dir() {
        if let Err(err) = set_cargo_version(package_version, "capable/capable/Cargo.toml") {
            eprintln!("cargo:warning={}", err);
        }
        if let Err(err) =
            set_cargo_version(package_version, "capable/capable-ebpf/Cargo.toml")
        {
            eprintln!("cargo:warning={}", err);
        }
        if let Err(err) =
            set_cargo_version(package_version, "capable/capable-common/Cargo.toml")
        {
            eprintln!("cargo:warning={}", err);
        }
    }
    if Path::new("xtask").is_dir() {
        if let Err(err) = set_cargo_version(package_version, "xtask/Cargo.toml") {
            eprintln!("cargo:warning={}", err);
        }
    }
    if Path::new("rar-common").is_dir() {
        if let Err(err) = set_cargo_version(package_version, "rar-common/Cargo.toml") {
            eprintln!("cargo:warning={}", err);
        }
    }
    if let Err(err) = set_readme_version(package_version, "README.md") {
        eprintln!("cargo:warning={}", err);
    }
    f.flush().unwrap();
}
